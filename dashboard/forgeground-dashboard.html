<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pickle ‚Ä¢ Data Preservation Engine - Live Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f1410;
            color: #e0e0e0;
            overflow: hidden;
        }

        /* Root layout */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: 64px 1fr 200px;
            height: 100vh;
            gap: 8px;
            padding: 8px;
            background: linear-gradient(135deg, #0f1410 0%, #1a2218 100%);
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            background: rgba(20, 30, 22, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(100, 200, 100, 0.2);
            border-radius: 8px;
        }

        .logo {
            font-size: 20px;
            font-weight: 700;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, #2dd45e, #68d878);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-stats {
            display: flex;
            gap: 32px;
            font-size: 13px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-label {
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
        }

        .stat-value {
            font-weight: 600;
            color: #2dd45e;
            font-size: 14px;
        }

        /* Main 3D viewport */
        #viewport {
            grid-column: 1;
            grid-row: 2;
            background: radial-gradient(ellipse at 50% 50%, rgba(45, 212, 94, 0.08) 0%, transparent 70%),
                        linear-gradient(to bottom, #0f1410, #1a2218);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(45, 212, 94, 0.15);
        }

        /* Right sidebar */
        .sidebar {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .panel {
            background: rgba(20, 30, 22, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(45, 212, 94, 0.15);
            border-radius: 8px;
            padding: 16px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #2dd45e;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.1);
        }

        /* Leaderboard */
        .leaderboard {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .leaderboard-entry {
            padding: 10px;
            background: rgba(15, 30, 20, 0.5);
            border-left: 3px solid #2dd45e;
            border-radius: 4px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .leaderboard-entry.top-1 { border-left-color: #ffd700; background: rgba(255, 215, 0, 0.1); }
        .leaderboard-entry.top-2 { border-left-color: #c0c0c0; background: rgba(192, 192, 192, 0.1); }
        .leaderboard-entry.top-3 { border-left-color: #cd7f32; background: rgba(205, 127, 50, 0.1); }

        .leaderboard-rank {
            font-weight: 700;
            color: #2dd45e;
            min-width: 20px;
        }

        .leaderboard-rank.top-1 { color: #ffd700; }
        .leaderboard-rank.top-2 { color: #c0c0c0; }
        .leaderboard-rank.top-3 { color: #cd7f32; }

        .leaderboard-info {
            flex: 1;
            margin: 0 12px;
        }

        .leaderboard-name {
            font-weight: 600;
            color: #fff;
        }

        .leaderboard-stats {
            font-size: 10px;
            color: #888;
        }

        .leaderboard-reward {
            text-align: right;
            font-weight: 600;
            color: #2dd45e;
        }

        /* AI Performance Panel */
        .ai-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .ai-item {
            padding: 8px;
            background: rgba(15, 30, 20, 0.5);
            border-left: 2px solid #2dd45e;
            border-radius: 4px;
            font-size: 11px;
        }

        .ai-name {
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .ai-metric {
            display: flex;
            justify-content: space-between;
            color: #888;
            margin: 2px 0;
        }

        .ai-metric-value {
            color: #2dd45e;
            font-weight: 500;
        }

        /* Bottom bonding curve */
        .bottom-panel {
            grid-column: 1 / -1;
            grid-row: 3;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 8px;
        }

        .curve-container {
            background: rgba(20, 30, 22, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(45, 212, 94, 0.15);
            border-radius: 8px;
            padding: 16px;
            position: relative;
            overflow: hidden;
        }

        #bondingCurve {
            width: 100%;
            height: 100%;
        }

        .work-queue {
            background: rgba(20, 30, 22, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(45, 212, 94, 0.15);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .work-type {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .work-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .work-indicator.crypto { background: #2dd45e; }
        .work-indicator.supply { background: #68d878; }
        .work-indicator.ml { background: #bfff44; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .work-label {
            flex: 1;
        }

        .work-count {
            color: #2dd45e;
            font-weight: 600;
        }

        .match-info {
            background: rgba(20, 30, 22, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(45, 212, 94, 0.15);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(45, 212, 94, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2dd45e, #68d878);
            transition: width 0.3s ease;
        }

        /* Scrollbar styling */
        .panel::-webkit-scrollbar {
            width: 6px;
        }

        .panel::-webkit-scrollbar-track {
            background: rgba(45, 212, 94, 0.05);
        }

        .panel::-webkit-scrollbar-thumb {
            background: rgba(45, 212, 94, 0.3);
            border-radius: 3px;
        }

        /* Validation animation */
        @keyframes validate {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.5); }
        }

        .validation-flash {
            animation: validate 0.6s ease-out;
        }

        /* Control button */
        .control-button {
            background: rgba(45, 212, 94, 0.2);
            border: 1px solid rgba(45, 212, 94, 0.5);
            color: #2dd45e;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .control-button:hover {
            background: rgba(45, 212, 94, 0.4);
            border-color: rgba(45, 212, 94, 1);
        }

        .control-button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <!-- Header -->
        <div class="header">
            <div class="logo">ü•í PICKLE ‚Ä¢ LIVE GAME</div>
            <div class="header-stats">
                <div class="stat">
                    <div class="stat-label">Work Queue</div>
                    <div class="stat-value" id="matchStatus">Loading...</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Prize Pool</div>
                    <div class="stat-value" id="prizePool">$0.00</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Validators Active</div>
                    <div class="stat-value" id="validatorsCount">0 AIs</div>
                </div>
            </div>
        </div>

        <!-- Main 3D Viewport -->
        <div id="viewport"></div>

        <!-- Right Sidebar -->
        <div class="sidebar">
            <!-- Leaderboard -->
            <div class="panel">
                <div class="panel-title">üèÜ Leaderboard</div>
                <div class="leaderboard" id="leaderboard">
                    <div style="color: #888; text-align: center; padding: 20px;">Loading validators...</div>
                </div>
            </div>

            <!-- Work Queue Stats -->
            <div class="panel">
                <div class="panel-title">‚ö° Work Distribution</div>
                <div class="work-queue">
                    <div class="work-type">
                        <div class="work-indicator crypto"></div>
                        <div class="work-label">Crypto Validation</div>
                        <div class="work-count" id="cryptoCount">0</div>
                    </div>
                    <div class="work-type">
                        <div class="work-indicator supply"></div>
                        <div class="work-label">Supply Chain</div>
                        <div class="work-count" id="supplyCount">0</div>
                    </div>
                    <div class="work-type">
                        <div class="work-indicator ml"></div>
                        <div class="work-label">ML Data</div>
                        <div class="work-count" id="mlCount">0</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom: Bonding Curve + Info -->
        <div class="bottom-panel">
            <div class="curve-container">
                <div class="panel-title" style="margin-bottom: 8px;">üìà Bonding Curve</div>
                <canvas id="bondingCurve"></canvas>
            </div>

            <div class="work-queue" style="flex-direction: row; align-items: center; justify-content: space-around; padding: 16px;">
                <div style="text-align: center;">
                    <div class="stat-label">Total Units</div>
                    <div class="stat-value" style="font-size: 20px;" id="totalUnits">0</div>
                </div>
                <div style="text-align: center;">
                    <div class="stat-label">Price/Unit</div>
                    <div class="stat-value" style="font-size: 20px;" id="pricePerUnit">$0.00</div>
                </div>
            </div>

            <div class="match-info">
                <div style="display: flex; gap: 8px;">
                    <button class="control-button" onclick="game.submitRandomWork()">+ Add Work</button>
                    <button class="control-button" onclick="game.reset()">Reset</button>
                </div>
                <div>
                    <div class="stat-label">Validation Rate</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="validationRate" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // PICKLE LIVE GAME ENGINE
        // ============================================

        class PickleGame {
            constructor() {
                this.validators = [
                    { id: 1, name: 'Validator Prime', specialization: 'crypto', speed: 1.2, accuracy: 0.94, color: 0x2dd45e, validated: 0, earned: 0 },
                    { id: 2, name: 'DataFlow', specialization: 'supply', speed: 0.9, accuracy: 0.87, color: 0x4dd468, validated: 0, earned: 0 },
                    { id: 3, name: 'PyroMind', specialization: 'ml', speed: 0.8, accuracy: 0.78, color: 0x68d878, validated: 0, earned: 0 },
                    { id: 4, name: 'NeuralSwarm', specialization: 'crypto', speed: 0.95, accuracy: 0.91, color: 0xbfff44, validated: 0, earned: 0 }
                ];

                this.workQueue = [];
                this.workTypes = ['crypto', 'supply', 'ml'];
                this.totalUnitsValidated = 0;
                this.prizePool = 0;
                this.basePrice = 1.2;
                this.priceMultiplier = 0.00015;

                this.bonding_curve_data = {
                    labels: [],
                    prices: []
                };

                this.validationRate = 0;
                this.validationCounter = 0;
            }

            submitWork(type) {
                const work = {
                    id: `work_${Date.now()}_${Math.random()}`,
                    type: type || this.workTypes[Math.floor(Math.random() * this.workTypes.length)],
                    submittedAt: Date.now(),
                    status: 'pending'
                };
                this.workQueue.push(work);
                return work;
            }

            assignAndValidate() {
                if (this.workQueue.length === 0) return;

                const work = this.workQueue.shift();
                const matchedValidators = this.validators.filter(v => {
                    // 50% chance for specialists, 30% for others
                    return v.specialization === work.type ? Math.random() < 0.6 : Math.random() < 0.3;
                });

                const validator = matchedValidators.length > 0
                    ? matchedValidators[Math.floor(Math.random() * matchedValidators.length)]
                    : this.validators[Math.floor(Math.random() * this.validators.length)];

                const validationTime = Math.random() * (500 / validator.speed) + 100;
                const isAccurate = Math.random() < validator.accuracy;

                setTimeout(() => {
                    if (isAccurate) {
                        this.completeValidation(validator, work);
                    }
                }, validationTime);
            }

            completeValidation(validator, work) {
                validator.validated++;
                this.totalUnitsValidated++;
                this.validationCounter++;

                // Update prize pool
                const price = this.basePrice + (this.totalUnitsValidated * this.priceMultiplier);
                const reward = price * 0.25; // Simplified reward

                validator.earned += reward;
                this.prizePool += price;

                // Track for bonding curve
                if (this.totalUnitsValidated % 10 === 0) {
                    this.bonding_curve_data.labels.push(this.totalUnitsValidated);
                    this.bonding_curve_data.prices.push(price);
                }

                this.updateUI();
            }

            getCurrentPrice() {
                return this.basePrice + (this.totalUnitsValidated * this.priceMultiplier);
            }

            updateUI() {
                // Update header stats
                document.getElementById('matchStatus').textContent = `${this.workQueue.length} pending`;
                document.getElementById('prizePool').textContent = `$${this.prizePool.toFixed(2)}`;
                document.getElementById('validatorsCount').textContent = `${this.validators.length} AIs`;

                // Update leaderboard
                const sorted = [...this.validators].sort((a, b) => b.earned - a.earned);
                const leaderboard = document.getElementById('leaderboard');
                leaderboard.innerHTML = sorted.map((v, idx) => `
                    <div class="leaderboard-entry ${idx === 0 ? 'top-1' : idx === 1 ? 'top-2' : idx === 2 ? 'top-3' : ''}">
                        <div class="leaderboard-rank ${idx === 0 ? 'top-1' : idx === 1 ? 'top-2' : idx === 2 ? 'top-3' : ''}">#${idx + 1}</div>
                        <div class="leaderboard-info">
                            <div class="leaderboard-name">${v.name}</div>
                            <div class="leaderboard-stats">${v.validated} validated ‚Ä¢ ${(v.accuracy * 100).toFixed(0)}% acc</div>
                        </div>
                        <div class="leaderboard-reward">$${v.earned.toFixed(2)}</div>
                    </div>
                `).join('');

                // Work type counts
                const cryptoCount = this.workQueue.filter(w => w.type === 'crypto').length;
                const supplyCount = this.workQueue.filter(w => w.type === 'supply').length;
                const mlCount = this.workQueue.filter(w => w.type === 'ml').length;
                document.getElementById('cryptoCount').textContent = cryptoCount;
                document.getElementById('supplyCount').textContent = supplyCount;
                document.getElementById('mlCount').textContent = mlCount;

                // Stats
                document.getElementById('totalUnits').textContent = this.totalUnitsValidated;
                document.getElementById('pricePerUnit').textContent = `$${this.getCurrentPrice().toFixed(2)}`;

                // Validation rate
                this.validationRate = Math.min(100, (this.validationCounter % 100) * (100 / 100));
                document.getElementById('validationRate').style.width = this.validationRate + '%';

                // Update charts
                updateBondingChart();
            }

            submitRandomWork() {
                for (let i = 0; i < 5; i++) {
                    this.submitWork();
                    setTimeout(() => this.assignAndValidate(), i * 50);
                }
            }

            reset() {
                this.validators.forEach(v => {
                    v.validated = 0;
                    v.earned = 0;
                });
                this.workQueue = [];
                this.totalUnitsValidated = 0;
                this.prizePool = 0;
                this.bonding_curve_data = { labels: [], prices: [] };
                this.updateUI();
            }
        }

        const game = new PickleGame();

        // THREE.JS SCENE SETUP
        const viewport = document.getElementById('viewport');
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0f1410, 100, 500);

        const camera = new THREE.PerspectiveCamera(75, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
        camera.position.set(0, 40, 40);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        renderer.setClearColor(0x0f1410, 0.1);
        renderer.shadowMap.enabled = true;
        viewport.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x2dd45e, 1, 200);
        pointLight.position.set(50, 50, 50);
        pointLight.castShadow = true;
        scene.add(pointLight);

        // Grid
        const gridHelper = new THREE.GridHelper(100, 20, 0x2dd45e, 0x1a3d2a);
        gridHelper.position.y = -0.1;
        scene.add(gridHelper);

        // Dynamic work particles
        const particlesGeometry = new THREE.BufferGeometry();
        const maxParticles = 2000;
        const positions = new Float32Array(maxParticles * 3);
        const colors = new Float32Array(maxParticles * 3);

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.6,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // AI validator nodes
        const aiNodes = game.validators.map((validator, i) => {
            const angle = (i / game.validators.length) * Math.PI * 2;
            const x = Math.cos(angle) * 30;
            const z = Math.sin(angle) * 30;

            const geometry = new THREE.IcosahedronGeometry(2.5, 4);
            const material = new THREE.MeshStandardMaterial({
                color: validator.color,
                emissive: validator.color,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });

            const node = new THREE.Mesh(geometry, material);
            node.position.set(x, 15, z);
            node.castShadow = true;
            scene.add(node);

            const glowGeometry = new THREE.IcosahedronGeometry(4, 4);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: validator.color,
                transparent: true,
                opacity: 0.1
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(x, 15, z);
            scene.add(glow);

            return {
                mesh: node,
                glow: glow,
                position: { x, y: 15, z },
                validator: validator,
                workInProgress: 0
            };
        });

        // Neural connections
        const connections = [];
        for (let i = 0; i < aiNodes.length; i++) {
            for (let j = i + 1; j < aiNodes.length; j++) {
                const points = [
                    new THREE.Vector3(aiNodes[i].position.x, aiNodes[i].position.y, aiNodes[i].position.z),
                    new THREE.Vector3(aiNodes[j].position.x, aiNodes[j].position.y, aiNodes[j].position.z)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x2dd45e,
                    transparent: true,
                    opacity: 0.2
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);

                connections.push({
                    line: line,
                    from: i,
                    to: j,
                    intensity: 0
                });
            }
        }

        // Animation loop
        let time = 0;
        let particleCount = 0;
        const positionAttribute = particlesGeometry.getAttribute('position');
        const colorAttribute = particlesGeometry.getAttribute('color');

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Spawn particles when work is being validated
            if (game.validationCounter > 0 && particleCount < maxParticles * 0.8) {
                for (let v of aiNodes) {
                    if (Math.random() < 0.3) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * 20 + 5;
                        const y = 15 + (Math.random() - 0.5) * 10;

                        if (particleCount < maxParticles) {
                            positions[particleCount * 3] = v.position.x + Math.cos(angle) * radius;
                            positions[particleCount * 3 + 1] = y;
                            positions[particleCount * 3 + 2] = v.position.z + Math.sin(angle) * radius;

                            const colorType = ['crypto', 'supply', 'ml'];
                            const idx = Math.floor(Math.random() * 3);
                            const colorMap = {
                                crypto: [0.2, 0.8, 0.3],
                                supply: [0.3, 0.9, 0.2],
                                ml: [0.8, 0.8, 0.1]
                            };
                            const c = colorMap[colorType[idx]];
                            colors[particleCount * 3] = c[0];
                            colors[particleCount * 3 + 1] = c[1];
                            colors[particleCount * 3 + 2] = c[2];

                            particleCount++;
                        }
                    }
                }
            }

            // Animate particles
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3 + 1] += Math.sin(time + i) * 0.08;
                if (positions[i * 3 + 1] > 50 || positions[i * 3 + 1] < -50) {
                    // Reset
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 30;
                }
            }
            positionAttribute.needsUpdate = true;
            particlesGeometry.setDrawRange(0, particleCount);

            // Animate validator nodes
            aiNodes.forEach((node, i) => {
                node.mesh.rotation.x += 0.003;
                node.mesh.rotation.y += 0.005;
                node.mesh.position.y = 15 + Math.sin(time * 0.5 + i) * 2;

                // Glow pulses based on work
                const thinking = Math.sin(time + i * 1.5) * 0.5 + 0.5;
                node.glow.material.opacity = 0.05 + thinking * 0.15 + (node.validator.validated / 100) * 0.1;
            });

            // Update connections based on validation activity
            connections.forEach((conn, idx) => {
                const activity = Math.random() * 0.3;
                conn.intensity = Math.max(0.05, conn.intensity - 0.02);
                conn.intensity = Math.min(0.5, conn.intensity + activity);

                conn.line.material.opacity = conn.intensity;
            });

            renderer.render(scene, camera);
        }

        animate();

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = viewport.clientWidth / viewport.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        });

        // BONDING CURVE CHART
        let chart = null;

        function updateBondingChart() {
            const ctx = document.getElementById('bondingCurve');
            if (!ctx) return;

            const data = {
                labels: game.bonding_curve_data.labels.length > 0
                    ? game.bonding_curve_data.labels.map(l => `${l}u`)
                    : ['Start'],
                datasets: [{
                    label: 'Price Per Unit',
                    data: game.bonding_curve_data.prices.length > 0
                        ? game.bonding_curve_data.prices
                        : [game.basePrice],
                    borderColor: '#2dd45e',
                    backgroundColor: 'rgba(45, 212, 94, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointBackgroundColor: '#2dd45e',
                    pointBorderColor: '#fff',
                    pointRadius: 3,
                    pointHoverRadius: 5
                }]
            };

            if (chart) {
                chart.data = data;
                chart.update();
            } else {
                chart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 5,
                                ticks: { color: '#888', font: { size: 10 } },
                                grid: { color: 'rgba(0, 212, 255, 0.1)' }
                            },
                            x: {
                                ticks: { color: '#888', font: { size: 10 } },
                                grid: { display: false }
                            }
                        }
                    }
                });
            }
        }

        // Initialize
        updateBondingChart();
        game.updateUI();

        // Auto-submit work every 2 seconds
        setInterval(() => {
            if (Math.random() > 0.4) {
                game.submitWork();
                game.assignAndValidate();
            }
        }, 2000);
    </script>
</body>
</html>
